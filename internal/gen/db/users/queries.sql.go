// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"

	"github.com/dmytro-kucherenko/smartner-utils-package/pkg/types"
	"github.com/google/uuid"
)

const count = `-- name: Count :one
SELECT COUNT(*)
FROM users
`

func (q *Queries) Count(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countStmt, count)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const create = `-- name: Create :one
INSERT INTO users (
    first_name,
    last_name,
    email,
    password_hash,
    password_salt
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
  )
RETURNING id, first_name, last_name, email, password_hash, password_salt, created_at, updated_at
`

type CreateParams struct {
	FirstName    string
	LastName     string
	Email        string
	PasswordHash string
	PasswordSalt string
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (User, error) {
	row := q.queryRow(ctx, q.createStmt, create,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.PasswordHash,
		arg.PasswordSalt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordSalt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const delete = `-- name: Delete :one
DELETE FROM users
WHERE id = $1
RETURNING id, first_name, last_name, email, password_hash, password_salt, created_at, updated_at
`

func (q *Queries) Delete(ctx context.Context, id types.ID) (User, error) {
	row := q.queryRow(ctx, q.deleteStmt, delete, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordSalt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findOne = `-- name: FindOne :one
SELECT id, first_name, last_name, email, password_hash, password_salt, created_at, updated_at
FROM users
WHERE (
    $1::uuid IS NULL
    OR id = $1::uuid
  )
  AND (
    $2::varchar IS NULL
    OR email = $2::varchar
  )
LIMIT 1
`

type FindOneParams struct {
	ID    uuid.NullUUID
	Email sql.NullString
}

func (q *Queries) FindOne(ctx context.Context, arg FindOneParams) (User, error) {
	row := q.queryRow(ctx, q.findOneStmt, findOne, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordSalt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPage = `-- name: FindPage :many
SELECT id, first_name, last_name, email, password_hash, password_salt, created_at, updated_at
FROM users
LIMIT $1 OFFSET $2
`

type FindPageParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) FindPage(ctx context.Context, arg FindPageParams) ([]User, error) {
	rows, err := q.query(ctx, q.findPageStmt, findPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.PasswordHash,
			&i.PasswordSalt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update = `-- name: Update :one
UPDATE users
SET first_name = COALESCE($1::varchar(255), first_name),
  last_name = COALESCE($2::varchar(255), last_name),
  password_hash = COALESCE(
    $3::varchar(255),
    password_hash
  ),
  password_salt = COALESCE(
    $4::varchar(255),
    password_salt
  )
WHERE id = $5
RETURNING id, first_name, last_name, email, password_hash, password_salt, created_at, updated_at
`

type UpdateParams struct {
	FirstName    sql.NullString
	LastName     sql.NullString
	PasswordHash sql.NullString
	PasswordSalt sql.NullString
	ID           types.ID
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (User, error) {
	row := q.queryRow(ctx, q.updateStmt, update,
		arg.FirstName,
		arg.LastName,
		arg.PasswordHash,
		arg.PasswordSalt,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordSalt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
